# 心跳机制

<!--
create time: 2019-02-16 01:55:03
Author: <黄东鸿>
-->

### 什么是心跳机制？ 　　

　　想一下， 当tcp连接被破坏后， 如果是死连接了， 服务端和客户端怎样才能知道信息能不能到达对方呢？ 很自然的想法是， 不断地给对方发探测信号， 看有没有回应， 这就是心跳机制的直白原理。 
　　所谓的心跳即是数据包， 发心跳就是一方向另一方发送的数据包， 不断地发送， 如果收不到回应， 那么就有理由认为是tcp连接出了问题。 那为什么要叫心跳呢？ 你摸一下你的心， 你看它是不是均匀在跳？ 理解了吧， 均匀发出去的数据包就类似于均匀的心跳信号。 所以， 我要说： 心跳就是（探测性的）数据包。 
　　 
　　之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。

判断对方（设备，进程或其它网元）是否正常动行，一般采用定时发送简单的通讯包，如果在指定时间段内未收到对方响应，则判断对方已经当掉。用于检测TCP的异常断开。 

基本原因是服务器端不能有效的判断客户端是否在线也就是说，服务器无法区分客户端是长时间在空闲，还是已经掉线的情况。所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。 

代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息。如果服务端几分钟内没有收到客户端信息则视客户端断开。比如有些通信软件长时间不使用，要想知道它的状态是在线还是离线就需要心跳包，定时发包收包。 
发包方可以是客户也可以是服务端，看哪边实现方便合理。一般是客户端。服务器也可以定时轮询发心跳下去。 

**一般来说，出于效率的考虑，是由客户端主动向服务器端发包，而不是相反。**

### 为什么需要心跳机制？

　　采用TCP连接的C/S模式软件，连接的双方在连接空闲状态时，如果任意一方意外崩溃、当机、网线断开或路由器故障，另一方无法得知TCP连接已经失效，除非继续在此连接上发送数据导致错误返回。很多时候，这不是我们需要的。我们希望服务器端和客户端都能及时有效地检测到连接失效，然后优雅地完成一些清理工作并把错误报告给用户。 

TCP连接的特点是如果两边一个数据包都不发，那么就不能保证两边的状态同步，设想一个连接建立起来之后， 网络中断了，一方尝试发送数据，超时数次之后会重置连接，回到没有连接的状态，但整个过程中对面都没有收到任何数据也没有发出任何数据，所以状态不变，之后的很长时间，对面都会以为自己的连接是已经建立的状态。只有使用心跳机制才能解决这个问题。顺便说一句，TCP keepalive不能完全解决这个问题，如果中间有负载均衡之类的设备，除非设备本身配了keepalive，否则仍然可能出现连接不能正常清除的情况。

#### 为什么应用层需要heart beat/心跳包？

1. 默认的tcp keep-alive超时时间太长

默认是7200秒，也就是2个小时。

2. socks proxy会让tcp keep-alive失效

socks协议只管转发TCP层具体的数据包，而不会转发TCP协议内的实现细节的包（也做不到），参考socks_proxy。

所以，一个应用如果使用了socks代理，那么tcp keep-alive机制就失效了，所以应用要自己有心跳包。

socks proxy只是一个例子，真实的网络很复杂，可能会有各种原因让tcp keep-alive失效。

3. 移动网络需要信令保活

前两年，微信信令事件很火，搜索下“微信 信令”或者“移动网络 信令”可以查到很多相关文章。

这里附上一个链接：[微信的大规模使用真的会过多占用信令，影响通讯稳定吗？](http://www.zhihu.com/question/20849677/answer/16384522)
　　
### 怎么来实现它？

　　如何及时有效地检测到一方的非正常断开，一直有两种技术可以运用。

* 一种是由TCP协议层实现的Keepalive
* 另一种是由应用层自己实现的心跳包。

　　在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：`SO_KEEPALIVE`。系统默认是设置的`2小时`的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。 
　　心跳包一般来说都是在逻辑层发送空的echo包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。 
　　其实，要判定掉线，只需要send或者recv一下，如果结果为零，则为掉线。但是，在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。 
　　在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀……当然，这个自然是要由逻辑层根据需求去做了。 

**总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。**

### 心跳检测步骤：

1. 客户端每隔一个时间间隔发生一个探测包给服务器 
2. 客户端发包时启动一个超时定时器 
3. 服务器端接收到检测包，应该回应一个包 
4. 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器 
5. 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了（连接断了/网络不稳定）

### 心跳包的发送

#### 方法1：应用层自己实现的心跳包

　　由应用程序自己发送心跳包来检测连接是否正常，大致的方法是： 
　　服务器在一个 Timer事件中定时 向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。

#### 方法2：TCP的KeepAlive保活机制

　　因为要考虑到一个服务器通常会连接多个客户端，因此由用户在应用层自己实现心跳包，代码较多 且稍显复杂，而利用TCP／IP协议层为内置的KeepAlive功能来实现心跳功能则简单得多。 
　　不论是服务端还是客户端，一方开启KeepAlive功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。 　 
　　因为开启KeepAlive功能需要消耗额外的宽带和流量，所以TCP协议层默认并不开启KeepAlive功 能，尽管这微不足道，但在按流量计费的环境下增加了费用，另一方面，KeepAlive设置不合理时可能会 因为短暂的网络波动而断开健康的TCP连接。并且，默认的KeepAlive超时需要7,200，000 MilliSeconds， 即2小时，探测次数为5次。对于很多服务端应用程序来说，2小时的空闲时间太长。因此，我们需要手工开启KeepAlive功能并设置合理的KeepAlive参数。

　　根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。 
具体操作：

```
//设置KeepAlive     
   1、 BOOL   bKeepAlive   =   TRUE;     
    int nRet=::setsockopt(sockClient,SOL_SOCKET,SO_KEEPALIVE,(char*)&bKeepAlive,sizeof(bKeepAlive));     
    if(nRet!=0)    
    {     
        AfxMessageBox("出错"); 
        return   ;
    }     

   2、感觉两小时时间太长可以自行设定方法1 
//设置KeepAlive检测时间和次数     
    tcp_keepalive    inKeepAlive   =   {0};   //输入参数     
    unsigned   long   ulInLen   =   sizeof(tcp_keepalive );         

    tcp_keepalive    outKeepAlive   =   {0};   //输出参数     
    unsigned   long   ulOutLen   =   sizeof(tcp_keepalive );         

    unsigned   long   ulBytesReturn   =   0;     

    //设置socket的keep   alive为10秒，并且发送次数为3次     
    inKeepAlive.onoff   =   1;       
    inKeepAlive.keepaliveinterval   =   4000;   //两次KeepAlive探测间的时间间隔     
    inKeepAlive.keepalivetime   =   1000;   //开始首次KeepAlive探测前的TCP空闭时间     

    nRet=WSAIoctl(sockClient,       
        SIO_KEEPALIVE_VALS,     
        (LPVOID)&inKeepAlive,     
        ulInLen,     
        (LPVOID)&outKeepAlive,     
        ulOutLen,     
        &ulBytesReturn,     
        NULL,     
        NULL);     
    if(SOCKET_ERROR   ==   nRet)     
    {     
        AfxMessageBox("出错");
        return;    
    }   
3、感觉两小时时间太长可以自行设定方法2
因此我们可以得到
    int                 keepIdle = 6;
    int                 keepInterval = 5;
    int                 keepCount = 3;
    Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle));
    Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
    Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));
```

详见：http://blog.csdn.net/gavin1203/article/details/5290609 

对setsockopt的操作，详见：http://www.cnblogs.com/hateislove214/archive/2010/11/05/1869886.html

### 服务端主动发送心跳包，还是客户端发送比较好？

如果是长连接的话，两边都要发。或者其中一边是被动方式，如果一段时间收不到心跳包就直接断开连接，也行。TCP连接的特点是如果两边一个数据包都不发，那么就不能保证两边的状态同步，设想一个连接建立起来之后， 网络中断了，一方尝试发送数据，超时数次之后会重置连接，回到没有连接的状态，但整个过程中对面都没有收到任何数据也没有发出任何数据，所以状态不变，之后的很长时间，对面都会以为自己的连接是已经建立的状态。只有使用心跳机制才能解决这个问题。顺便说一句，TCP keepalive不能完全解决这个问题，如果中间有负载均衡之类的设备，除非设备本身配了keepalive，否则仍然可能出现连接不能正常清除的情况。可以有两种发送策略，一种是任何情况下都固定时间发，另一种是一段时间没有收发数据才发。

作者：灵剑
链接：https://www.zhihu.com/question/35896874/answer/116301692
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



心跳包机制一般两种：TCP自带的keep-alive；应用层探活。心跳包用来解决半连接问题。当服务器断电、断网、丢弃三次握手的ack包都可能造成客户端半连接，同时客户端断电、断网，或者中间设备故障也可能造成服务器端半连接。半连接出现后，从系统层面考虑，对服务器而言，害怕的是量大导致资源耗尽从而拒绝服务；对客户端而言，系统危害不大，连接一致性无法保证。从业务层面而言，如果是长连接的推送服务，如果客户端故障导致，将导致推送数据失败。基于上面的分析，能得出，心跳包让哪一方来发依赖于是否需要感知对方断开了通信连接。譬如，推送服务，显然服务器端和客户端都发比较好，这样客户端感知到服务器断开连接后主动重连；服务器感知感知到客户端断开连接后快速回收连接资源。那到底使用tcp的keep-alive还是应用层自己实现的心跳机制呢？keep-alive占用带宽少，不用开发人员实现。但在有代理的网络下，不一定能探活到服务器，除非反向代理也有相应的心跳机制；应用层心跳能携带更多状态，心跳包可以附带一些其他信息，定时在服务端和客户端之间同步。（比如帧数同步。

作者：曹东
链接：https://www.zhihu.com/question/35896874/answer/116336003
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


视业务情况而定。CS系统中服务端发心跳包的也常见，如一些CMPP短信网关。从服务端发送的好处在于便于集中管理，如一些协议的流水号包含递增数字，如由客户端生成易造成不必要的麻烦，另外在某些情况下服务端可以随时发心跳掌握客户端状态，不必等待。缺点是服务端开销较大，如开放系统有大量接入，如有很多链接异常，服务端还要发心跳则会浪费服务端资源。个人意见，如果是较封闭的系统（需要严格权限认证的环境），同时连接数相对较小的环境下可以考虑服务端发送心跳包。较为开放的系统，或连接数较多的环境（如互联网应用）应考虑客户端发心跳包。

举例而言，如果某个应用100万用户，但只有1万在线，如果服务端发心跳检测需要发起100万次通讯，客户端发心跳包则服务端只需处理1万次请求。

作者：匿名用户
链接：https://www.zhihu.com/question/35896874/answer/64932867
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


我们是客户端主动发送,要是服务器超时没收到,也会发送反向心跳包过来检测的

### 那么既然有TCP的心跳机制，我们为什么还要在应用层实现自己的心跳检测机制呢？

[TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制?? -- 知乎](https://www.zhihu.com/question/40602902)

![](https://pic4.zhimg.com/80/v2-7462b3fbeaf5a5e4d060e9bcebb6dec3_hd.jpg)

解决的问题不一样。
tcp keepalive检查连接是否存活。
应用keppalive检测应用是否正常可响应。

举个栗子。服务端死锁，无法处理任何业务请求。但是操作系统仍然可以响应网络层keepalive包。


级别不一样，比如数据库坏掉了，应用程序失败了，但是跟客户端的tcp完好无损。

tcp 的keepalive设计思想保证的是tcp协议连接的健全
并不能保证你写的应用层的连接健全 你自己的应用还要你自己视情况自己写心跳



作者：Richard
链接：https://www.zhihu.com/question/40602902/answer/209940999
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

为什么要用心跳包我个人觉得在移动数据网络情景下最好解释...首先缺省时间前面大佬已经说了这个就直接略过吧缺省时间很长是不是？那我们把时间改短能不能代替心跳包？答案还是不能KeepAlive实际上只是去检查你这个连接是不是存活的 打个比方就是个管道 他来检查你这个管道是不是能通水那么excited的地方就来了！你怎么知道水厂能不能供水？这就是个很典型的例子 连接是保持了 但是服务端却无法处理业务，这个时候你觉得这个是存活还是不存活呢？而心跳包不会有这个问题 他的职责就是检查双方的存活状态，听起来好像是一回事？但是实际上不一样，正如之前所说KeepAlive查的是你这个连接是不是正常的 而心跳包是检查双方能不能正常交换数据~TCP长连接从本质上来说，不需要心跳包来维持~ 但是有些奇葩情况下就是辣么坑爹这个时候就不得不提到我一开始说的移动数据网络场景啦现在运营商的移动数据多为NAT方式 然后有些策略大概意思就是在一定时间内没有数据通过这个连接 他就直接给你砍啦~很坑爹是不是 这个时候心跳包就能起到一个保活的作用并且也能检查双方存活心跳是一个可选的方案 至于用不用就要看你的业务需求啦 修仙时写的 有错误欢迎指出（我觉得描述错误的可能性比较大的说 语文一直不太好）


tcpip详解卷1有网络异常中断的3种情况，比如os回收端口的时候发送的rst包，如果os挂了就不会发这个消息了。 另外如果网络异常，有可能收到路由器返回的icmp主机不可达消息从而关闭连接。 keepalive之所以不靠谱，是因为需要从socket error获知连接断开，而且是被动断开。 而应用层自己实现的heartbeat可以自主检测超时，更方便修改超时时间和断开前处理。

keepalive设计初衷清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性。而且keepalive好像还不能主动通知应用层，需要主动调用api去检测异常。

使用自己应用层的心跳包,上述方法用于正常情况下的TCP连接维护，

     场景举例如下:在游戏服务器当中，内存中维护着众多玩家的在线数据，以方便调用，比如玩家的英雄队伍信息，玩家的世界位置信息，在玩家下线的时候，服务器必须知道并且清除掉数据（不然就会出现一个已经下线的玩家出现在世界上），在上述举例中，在服务器端收到TCP连接中断的消息后，调用close，期间可以通过socket得到玩家socket数据，从而获得user信息（如果提前根据ip或者mac做了记录）从而清除数据。
     但是如果不是正常的玩家下线，TCP的四次握手没有成功，比如网络直接中断，client端的TCP协议的fin包没有发出去，服务端就不能及时探知玩家下线，如果依赖上面讲的TCP自己的keep alive探测机制，时间较长，做不到及时处理下线玩家，并且性能不佳，因为TCP/IP的设计者本身就不支持TCP的心跳，因为这可能因为中间网络的短暂中断导致两端良好的TCP连接断开。所以一般不启用TCP的心跳机制，那我们怎么处理这些异常下线呢？如果不处理，服务端将一直维护着TCP死连接，导致网络资源（一台服务器可以支持的TCP连接有限）和内存资源（内存中可能维护着该玩家的数据）的占用，所以就要用到应用层的心跳包了

     下面解释下应用层的心跳包：

     心跳包，通常是客户端每隔一小段时间向服务器发送的一个数据包，通知服务器自己仍然在线，服务器与客户端之间每隔一段时间 进行一次交互,来判断这个链接是否有效，并传输一些可能有必要的数据。通常是在建立了一个TCP的socket连接后无法保证这个连接是否持续有效，这时候两边应用会通过定时发送心跳包来保证连接是有效的。因按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。事实上为了保持长连接（长连接指的是建立一次TCP连接之后，就认为连接有效，利用这个连接去不断传输数据，不断开TCP连接），至于包的内容，是没有特别规定的，不过一般都是很小的包，或者只是包含包头的一个空包。

     那么心跳包的意义就在于方便的在服务端管理客户端的在线情况，并且可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。

因为TCP协议中的SO_KEEPALIVE有几个致命的缺陷：keepalive只能检测连接是否存活，不能检测连接是否可用。比如服务器因为负载过高导致无法响应请求但是连接仍然存在，此时keepalive无法判断连接是否可用。如果TCP连接中的另一方因为停电突然断网，我们并不知道连接断开，此时发送数据失败会进行重传，由于重传包的优先级要高于keepalive的数据包，因此keepalive的数据包无法发送出去。只有在长时间的重传失败之后我们才能判断此连接断开了。

问：额 重传失败不就自动断了么，这这时候发 keepalive 没意义啊

答：因为重传失败判断连接断开需要较长时间，达不到及时性失效检测。

问：一端停电断网的话，另一端发现连接中断需要经过的时间是只依赖于重传吗？此时keep alive不能帮助自己发现连接已断吗？期盼解答

答：在周期时间内没有任何数据接收和发送才会触发keepalive检测，在应用层发送数据失败会进行数次重传，会将定时器重置，因此无法触发keepalive检测。

作者：Eternity
链接：https://www.zhihu.com/question/40602902/answer/209148428
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

大概你们没有遇到过需要使用四层负载均衡之类的中继设备的情况，tcp_keepalive会终结到负载均衡上面，无法检测远端是否还连着。就算你能控制你自己的IP前面没有'中继设备，你也没法控制客户的网络会不会有个WAF或者sock5代理啥的。无法检测服务是否可用也是很重要的点。

作者：灵剑
链接：https://www.zhihu.com/question/40602902/answer/243161932
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


### 心跳包格式

TCP包的header中有一个字段记录是心跳包就行了，比如 type = heart