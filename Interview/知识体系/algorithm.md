
Algorithm
===========

### 队列\堆栈

##### 堆栈

* 后进先出（LIFO）
* 进栈/出栈操作均在数组尾部，时间复杂度=O(1)

##### 队列

* 先进先出（FIFO）
* 队列的书序存储结构：入列时间复杂度=O(1),出队列时间复杂度=O(n)
* 循环队列：解决出队列操作时间复杂度=O(n)的问题，使得时间复杂度=O(1)
* 队列的链式存储结构：入/出队列时间复杂度=O(1)

## 图论

### DFS和BFS的区别及其使用场景

* 区别: 
	* DFS是深度优先搜索，对一个无向连通图，在访问图中某一起始顶点v后，由v出发，访问它的某一邻接顶点w1；再从w1出发，访问与w1邻接但还没有访问过的顶点w2；然后再从w2出发，进行类似的访问;......;如此进行下去，直至到达所有邻接顶点都被访问过的顶点u为止；接着，回退一步，回退到前一次刚访问过的顶点，看是否还有其他没有被访问过的邻接顶点，如果有，则访问次顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行类似的访问。重复上述过程，直到该连通图中所有顶点都被访问过为止。
	* BFS是广度优先搜索，对一个无相连通图，在访问图中某一起始顶点v后，由v出发，依次访问v的所有未访问过的邻接顶点w1,w2,w3,...,wt;然后再顺序访问w1,w2,w3,...,wt;的所有还未访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们的所有还未访问过的邻接顶点，......，如此直到图中所有顶点都被访问到为止。

* 使用场景：
	* DFS：
	
		1) 适用于必须走到最深处（例如对于树，必须要走到叶子节点）才能得到一个解的情况
		
		2) 求可行解的总数，求一个可行解，求所有可行解
		
		3) 给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。
	* BFS：
	
		1) 一般只要求一个解
		
		2) 求最短路径

### DFS

> `DFS` 算法的思想是：对一个无向连通图，在访问图中某一起始顶点v后，由v出发，访问它的某一邻接顶点w1；再从w1出发，访问与w1邻接但还没有访问过的顶点w2；然后再从w2出发，进行类似的访问;......;如此进行下去，直至到达所有邻接顶点都被访问过的顶点u为止；接着，回退一步，回退到前一次刚访问过的顶点，看是否还有其他没有被访问过的邻接顶点，如果有，则访问次顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行类似的访问。重复上述过程，直到该连通图中所有顶点都被访问过为止。

从顶点v出发深度遍历图G的算法描述：

	① 访问v
	② 依次从顶点v未被访问的邻接点出发深度遍历。

如果用邻接表存储图，时间复杂度为O(n+2m)，DFS伪代码如下：

	DFS(顶点 i） {		// 从顶点i进行深度优先搜索
		visited[i] = 1;	// 将顶点i的访问标志置为1
		p = 顶点i的边链表表头指针;
		while( p 不为空 ) {
			// 设指针p所指向的边节点所表示的边中，另一个顶点为顶点j
			if (顶点j未访问过) {
				// 递归搜索前的准备工作需要在这里写代码
				DFS(顶点j);
				// 以下是DFS的回退位置，需要在这里写代码
			}
			p = p -> next; // p 移向下一个边节点
		}
	}
	
如果用邻接矩阵存储图，时间复杂度为O(n^2)，DFS伪代码如下：

	DFS(顶点 i） {		// 从顶点i进行深度优先搜索
		visited[i] = 1;	// 将顶点i的访问标志置为1
		p = 顶点i的边链表表头指针;
		for( j = 0; j < n ; j++ ) {	// 对其他所有顶点j
			// j是i的邻接顶点，且顶点j没有访问过
			if ( Edge[i][j] == 1 && !visited[j] ) {
				// 递归搜索前的准备工作需要在这里写代码
				DFS(顶点j);	// 从顶点j出发进行DFS搜索
				// 以下是DFS的回退位置，需要在这里写代码
			}
		}
	}
	
### BFS

> BFS 算法的思想是：对一个无相连通图，在访问图中某一起始顶点v后，由v出发，依次访问v的所有未访问过的邻接顶点w1,w2,w3,...,wt;然后再顺序访问w1,w2,w3,...,wt;的所有还未访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们的所有还未访问过的邻接顶点，......，如此直到图中所有顶点都被访问到为止。

如果用邻接表存储图，时间复杂度为O(n+2m)，DFS伪代码如下：

	BFS(顶点 i） {		// 从顶点i进行广度优先搜索
		visited[i] = 1;	// 将顶点i的访问标志置为1
		将顶点i入队列
		while( 队列不为空 ) {
			取出队列头的顶点，设为k
			p = 顶点k的边链表表头指针
			while ( p 不为空 ) {
				// 设指针p所指向的边节点所表示的边的另一个顶点为顶点j
				if ( 顶点j未访问过 ) {
					将顶点j的访问标志置为1
					将顶点j入队列
				}
				p = p -> next; // p 移向下一个边节点
			}
		}
	}
	
从顶点v出发遍历图G的算法买描述如下：

	①访问v
	②假设最近一层的访问顶点依次为vi1,vi2,vi3...vik，则依次访问vi1,vi2,vi3...vik的未被访问的邻接点
	③重复②知道没有未被访问的邻接点为止
	
如果用邻接矩阵存储图，时间复杂度为O(n^2)，DFS伪代码如下：

	BFS(顶点 i） {		// 从顶点i进行广度优先搜索
		visited[i] = 1;	// 将顶点i的访问标志置为1
		将顶点i入队列
		while( 队列不为空 ) {
			取出队列头的顶点，设为k
			for( j = 0; j < n ; j++ ) {	// 对其他所有顶点j
				// j是k的邻接顶点，且顶点j没有访问过
				if ( Edge[k][j] == 1 && !visited[j] ) {
					将顶点j的访问标志置为1
					将顶点j入队列
				}
			}
		}
	}
	
#### DFS和BFS的使用场景

我们假设一个节点衍生出来的相邻节点平均的个数是N个，那么当起点开始搜索的时候，队列有一个节点，当起点拿出来后，把它相邻的节点放进去，那么队列就有N个节点，当下一层的搜索中再加入元素到队列的时候，节点数达到了N2，你可以想想，一旦N是一个比较大的数的时候，这个树的层次又比较深，那这个队列就得需要很大的内存空间了。

于是广度优先搜索的缺点出来了：在树的层次较深&子节点数较多的情况下，消耗内存十分严重。**广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况**。

那么深度优先就可以克服这个缺点，因为每次搜的过程，每一层只需维护一个节点。但回过头想想，广度优先能够找到最短路径，那深度优先能否找到呢？深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，所以你还得继续走别的路去判断是否是最短路？

于是深度优先搜索的缺点也出来了：**难以寻找最优解，仅仅只能寻找有解**。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点。

[DFS和BFS遍历的问题](http://www.cnblogs.com/li-daphne/p/5543282.html)

DFS:

1. 深搜常见的三个问题，求可行解的总数，求一个可行解，求所有可行解。
2. 必须走到最深处（例如对于树，必须要走到叶子节点）才能得到一个解，适合深搜
3. 给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。
4. 递归由两种加速策略：
	* 1剪枝，对中间结果判断，提前返回。
	* 2缓存，缓存中间结果，防止重复计算，用空间换时间。


BFS：

1. 广搜一般只要求一个解
2. 求最短
3. BFS通常用hash表之类的判重，有多条路径到达一个状态的情况取最短路，DFS搜到一个
状态并不能保证路径是最短的
4. 考虑无界情况，深搜有可能就直接死了

## 二分查找

[二分查找法的实现和应用汇总](https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html)


## 数论

### N!末尾有几个0

##### 分析:

想到这个问题，有人可能第一反应就是现求出N!,然后再根据求出的结果，最后得出N!的末尾有多少个0。但是转念一想，一定会溢出，等等。其实，从"那些数相乘可以得到10"这个角度，问题就变得比较的简单了。
     
如果N！= K×10M，且K不能被10整除，那么N！末尾有M个0。再考虑对N！进行质因数分解，N！=（2^x）×（3^y）×（5^z）…，由于10 = 2×5，所以M只跟X和Z相关，每一对2和5相乘可以得到一个10，于是M = min（X, Z）。不难看出X大于等于Z，因为能被2整除的数出现的频率比能被5整除的数高得多，所以把公式简化为M = Z。
     
由上面的分析可以看出，只要计算处Z的值，就可以得到N!末尾0的个数。

##### 解法一

要计算Z，最直接的方法就是求出N！的所有因式(1,2,3,...,N)分解中5的指数。然后求和

```c
int fun1(int n)
{
    int num = 0;
    int i,j;
    
    for (i = 5;i <= n;i += 5)
    {
        j = i;
        while (j % 5 == 0)
        {
            num++;
            j /= 5;
        }
    }
    
    return num;
}
```

##### 解法二：

那么还有没有更简单点的方法呢？我们想，Z还能怎么样得到？举个例子，25的阶乘中，总共有6个五，其中5,10,15,20，各贡献一个，25贡献两个，也可以说成，5,10,15,20，25各贡献一个，25又额外贡献 一个，即5的倍数各贡献一个5,25的倍数各贡献一个5,即Z=[25/5] + [25/25]。同理，125中，5的倍数各贡献一个5,25的倍数各贡献一个5,125的倍数也各贡献一个5，所以Y=[125/5] + [125/25] + [125/125],所以可得公式：

Z = [N/5] + [N/5^2] + [N/5^3] + … （不用担心这会是一个无穷的运算，因为总存在一个K，使得5^K > N，[N/5^K]=0。）

公式中，[N/5]表示不大于N的数中5的倍数贡献一个5，[N/5^2]表示不大于N的数中5^2的倍数再贡献一个5，……

```c
int fun2(int n)
{
    int num = 0;
    
    while(n)
    {
        num += n / 5;
        n = n / 5;
    }
    
    return num;
}
```

----------------

### 求N！的二进制表示中最低位1的位置

##### 分析

为了得到更好的解法，首先要对题目进行一下转化。

首先来看一下一个二进制数除以2的计算过程和结果是怎样的。

一个二进制数乘以2就是把将此二进制数向左移一位，末位补零。除以2时，则要判断末位是否为0，若为0，向右移一位，若不能为0，则不能被2整除。

所以，这个问题实际上等同于**求N！含有质因数2的个数+1**。即答案等于N！含有质因数2的个数加1。 实际上N！都为偶数，因为质因数里面都有一个2，除了1以外，因为1的阶乘是1，是个奇数，其他数的阶乘都是偶数。。

##### 解法一

N! 中含有质因数2的个数，等于 N/(2^1) + N/(2^2) + N/(2^3) + N/(2^4) + …

根据上述分析，得到具体算法，如下所示：

```c
/* 
可以先求出N!中2的个数（因为每存在一个2，则在数的  
最低位多1个0）。因此求1的最低位的位置即为N!中2的个数+1；  
*/  
int lowestOnePos(int n)   
{   
    int ret = 0;     //统计n!中含有质因数2的个数  
    while(n)   
    {   
        n >>= 1;   
        ret += n;   
    }   
    return ret+1;  
}  
```

##### 解法二

N！含有质因数2的个数，还等于N减去N的二进制表示中1的数目。我们还可以通过这个规律来求解。

下面对这个规律进行举例说明，假设 N = 11011，那么N!中含有质因数2的个数为 N/2 + N/4 + N/8 + N/16 + …


	即： 1101 + 110 + 11 + 1
	
	=（1000 + 100 + 1）
	
	+（100 + 10）
	
	+（10 + 1）
	
	+ 1
	
	=（1000 + 100+ 10 + 1）+（100 + 10 + 1）+ 1
	
	= 1111 + 111 + 1
	
	=（10000 -1）+（1000 - 1）+（10-1）+（1-1）
	
	= 11011-N二进制表示中1的个数
	
## Hash

[浅谈算法和数据结构: 十一 哈希表](http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html)

## 面试题

[网易2017春招笔试：消除重复元素](http://group.jobbole.com/30315/?utm_source=blog.jobbole.com&utm_medium=article-related-group-topic)

### 不使用中间变量 实现 swap(x,y)

解法一: 使用加减法

```
x = x + y
y = x - y
x = x - y
```

解法二: 使用异或

```
x = x ^ y
y = x ^ y
x = x ^ y
```
