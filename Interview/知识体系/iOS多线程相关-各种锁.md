# iOS多线程相关-各种锁

<!--
create time: 2019-04-10 16:16:25
Author: <黄东鸿>
-->

[深入理解 iOS 开发中的锁](https://bestswifter.com/ios-lock)

[不再安全的 OSSpinLock](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)

iOS 中各种锁的加解锁性能对比:

![](./images/lock_benchmark.png)

## 多线程管理

### 1. 基础概念

* 临界资源: **临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。** 属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。

* 临界区: **每个进程中访问临界资源的那段代码称为临界区（criticalsection）**，每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。

* 原子性: **原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败**，有着“同生共死”的感觉。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

### 2. PV 操作和信号量

信号量是最早出现的用来解决进程同步与互斥问题的机制。

PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。

> 中国读者常常不明白这一同步机制为什么叫PV操作，原来这是 狄克斯特拉 用荷兰文定义的，因为在荷兰文中，通过叫 passeren，释放叫 vrijgeven，PV操作因此得名。这是在计算机术语中不是用英语表达的极少数的例子之一。

#### 信号量

信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。

* 当它的值大于0时，表示当前可用资源的数量；
* 当它的值小于0时，其绝对值表示等待使用该资源的进程个数。

注意，信号量的值仅能由PV操作来改变。

对一个信号量变量可以进行两种原语操作：P操作和V操作，定义如下：

```
procedure P(var s:semaphore) {
    s.value=s.value-1;
    if (s.value<0) 
        asleep(s.queue);
}

procedure V(var s:semaphore) {
    s.value=s.value+1;
    // 如果大于0，则进程继续执行; 如果小于等于0，则唤醒一阻塞在该信号量上的进程
    if (s.value<=0) 
        wakeup(s.queue);
}
```

一般来说，信号量S>=0时，S表示可用资源的数量。

* 执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。
* 执行一个V操作意味着释放一个单位资源，因此S的值加1；若S<0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。

利用信号量和PV操作实现进程互斥的一般模型是：

```
进程P1  进程P2  ……   进程Pn
……　    ……     ……   ……
P(S);   P(S);       P(S);
临界区;　临界区;　    临界区;
V(S);   V(S);       V(S);
……　    ……     ……   ……
```

其中信号量S用于互斥，初值为1。

使用PV操作实现进程互斥时应该注意的是：

1. 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。
2. P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。
3. 互斥信号量的初值一般为1。

## 5个经典的线程同步问题

### 生产者-消费者问题

**生产者消费者问题**（Producer-consumer problem），也称**有限缓冲问题**（Bounded-buffer problem），是一个多进程同步问题的经典案例。

该问题描述了共享固定大小缓冲区的两个进程（即所谓的“生产者”和“消费者”），在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。

该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也要让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。

通常采用“进程间通信”的方法解决该问题，常用的方法有信号量法等，如果解决方法不够完善，则容易出现活锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。

#### 1）不完善的实现

下面这个解决方法会导致竞争条件。该算法使用了两个系统库函数，sleep 和 wakeup，调用 sleep 的进程会被阻断，直到有另一个进程用 wakeup 唤醒之。代码中的 itemCount 用于记录缓冲区中的数据项数。

```
int itemCount = 0;

procedure producer() {
    while (true) {
        item = produceItem();
        if (itemCount == BUFFER_SIZE) {
            sleep();
        }
        putItemIntoBuffer(item);
        itemCount = itemCount + 1;
        if (itemCount == 1) {
            wakeup(consumer);
        }
    }
}

procedure consumer() {
    while (true) {
        if (itemCount == 0) {
            sleep();
        }
        item = removeItemFromBuffer();
        itemCount = itemCount - 1;
        if (itemCount == BUFFER_SIZE - 1) {
            wakeup(producer);
        }
        consumeItem(item);
    }
}
```

上面代码中的问题在于它可能导致竞争条件，进而引发死锁。考虑下面的情形：

1. 消费者把最后一个 itemCount 的内容读出来，注意它现在是零。消费者返回到while的起始处，现在进入 if 块；
2. 就在调用sleep之前，CPU决定将时间让给生产者，于是消费者在执行 sleep 之前就被中断了，生产者开始执行；
3. 生产者生产出一项数据后将其放入缓冲区，然后在 itemCount 上加 1；
4. 由于缓冲区在上一步加 1 之前为空，生产者尝试唤醒消费者；
5. 遗憾的是，消费者并没有在休眠，唤醒指令不起作用。当消费者恢复执行的时候，执行 sleep，一觉不醒。出现这种情况的原因在于，消费者只能被生产者在 itemCount 为 1 的情况下唤醒；
6. 生产者不停地循环执行，直到缓冲区满，随后进入休眠。

由于两个进程都进入了永远的休眠，死锁情况出现了。因此，该算法是不完善的。

#### 2）使用信号灯的算法

信号灯可以解决上述唤醒指令不起作用的问题。我们使用两个信号灯 fillCount 和 emptyCount。fillCount 用于记录缓冲区中将被读取的数据项数（实际上就是有多少数据项在缓冲区里），emptyCount 用于记录缓冲区中空闲空间数。当有新数据项被放入缓冲区时，fillCount 增加，emptyCount 减少。如果在生产者尝试减少 emptyCount 的时候发现其值为零，那么生产者就进入休眠。等到有数据项被消耗，emptyCount 增加的时候，生产者才被唤醒。消费者的行为类似。

```
semaphore fillCount = 0; // 生产的项目
semaphore emptyCount = BUFFER_SIZE; // 剩余空间

procedure producer() {
    while (true) {
        item = produceItem();
        down(emptyCount);
            putItemIntoBuffer(item);
        up(fillCount);
    }
}

procedure consumer() {
    while (true) {
        down(fillCount);
            item = removeItemFromBuffer();
        up(emptyCount);
        consumeItem(item);
    }
}
```

**上述方法只能解决只有一个生产者和一个消费者时的问题。** 对于多个生产者或者多个消费者共享缓冲区的情况，该算法也会导致竞争条件，出现两个或以上的进程同时读或写同一个缓冲区槽的情况。

为了说明这种情况是如何发生的，我们可以假设 putItemIntoBuffer() 的一种可能的实现：先寻找下一个可用空槽，然后写入数据项。下列情形是可能出现的：

1. 两个生产者都减少 emptyCount 的值；
2. 某一生产者寻找到下一个可用空槽；
3. 另一生产者也找到了下一个可用空槽，结果和上一步被找到的是同一个空槽；
4. 两个生产者向可用空槽写入数据。

**为了解决这个问题，需要在保证同一时刻只有一个生产者能够执行 putItemIntoBuffer()，也就是说，需要寻找一种方法来互斥地执行临界区的代码。** 为了达到这个目的，可引入一个二值信号量 mutex，其值只能为 1 或者 0。如果把线程放入 down(mutex) 和 up(mutex) 之间，就可以限制只有一个线程能被执行。多生产者、消费者的解决算法如下：

```
semaphore mutex = 1;
semaphore fillCount = 0;
semaphore emptyCount = BUFFER_SIZE;

procedure producer() {
    while (true) {
        item = produceItem();
        down(emptyCount);
            down(mutex);
                putItemIntoBuffer(item);
            up(mutex);
        up(fillCount);
    }
}
procedure consumer() {
    while (true) {
        down(fillCount);
            down(mutex);
                item = removeItemFromBuffer();
            up(mutex);
        up(emptyCount);
        consumeItem(item);
    }
}
```

#### 3）使用管程的算法

可以使用管程来解决生产者消费者问题的。由于管程一定能保证互斥，所以不必特地考虑保护临界区。下面的方法不用修改就可以推广适用于任意数量的生产者和消费者的情况。

```
monitor ProducerConsumer {
    int itemCount;
    condition full;
    condition empty;

    procedure add(item) {
        while (itemCount == BUFFER_SIZE)
            wait(full);
        putItemIntoBuffer(item);
        itemCount = itemCount + 1;
        if (itemCount == 1)
            notify(empty);
    }

    procedure remove() {
        while (itemCount == 0)
            wait(empty);
        item = removeItemFromBuffer();
        itemCount = itemCount - 1;
        if (itemCount == BUFFER_SIZE - 1)
            notify(full);
        return item;
    }
}

procedure producer() {
    while (true) {
        item = produceItem()
               ProducerConsumer.add(item)
    }
}

procedure consumer() {
    while (true) {
        item = ProducerConsumer.remove()
               consumeItem(item)
    }
}
```

### 哲学家就餐问题

哲学家就餐问题（Dining philosophers problem）是在计算机科学中的一个经典问题，用来演示在并发计算中多线程同步（Synchronization）时产生的问题。

在1971年，著名的计算机科学家 *艾兹格·迪科斯彻* 提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。稍后，这个问题被 *托尼·霍尔* 重新表述为"哲学家就餐问题"。这个问题可以用来解释死锁和资源耗尽。

问题描述

哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。


哲学家就餐问题的演示
哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。

即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。

在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而这永远不会发生。

#### 服务生解法

一个简单的解法是引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。因为服务生知道哪只餐叉正在使用，所以他能够作出判断避免死锁。

为了演示这种解法，假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁。

#### 资源分级解法

另一个简单的解法是为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。

尽管资源分级能避免死锁，但这种策略并不总是实用的，特别是当所需资源的列表并不是事先知道的时候。例如，假设一个工作单元拿着资源3和5，并决定需要资源2，则必须先要释放5，之后释放3，才能得到2，之后必须重新按顺序获取3和5。对需要访问大量数据库记录的计算机程序来说，如果需要先释放高编号的记录才能访问新的记录，那么运行效率就不会高，因此这种方法在这里并不实用。

#### Chandy/Misra解法

1984年，K. Mani Chandy和J. Misra提出了哲学家就餐问题的另一个解法，允许任意的用户（编号P1, ..., Pn）争用任意数量的资源。与资源分级解法不同的是，这里编号可以是任意的。

* 把餐叉凑成对，让要吃的人先吃，没餐叉的人得到一张换餐叉券。
* 饿了，把换餐叉券交给有餐叉的人，有餐叉的人吃饱了会把餐叉交给有券的人。有了券的人不会再得到第二张券。
* 保证有餐叉的都有得吃。

这个解法允许很大的并行性，适用于任意大的问题。

### 读者-写者问题

在计算机科学中 ， “读者-写者问题” 是一种在并发常见的一种计算问题的例子。 计算机在处理多个线程同时尝试访问同一共享资源的情况，有些线程可能会读取资源而有些线程可能会写入资源，当两个或以上的读进程同时访问共享数据时不会产生错误，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。

因此，该问题的限制条件是当一个进程对共享资源进行读取或写入时，另一个进程无法写入它。它可以被两个或更多的读者进程在同一时间访问，但只能被唯一的写者进程访问。

#### 读进程优先

1) 关系分析: 由问题分析得出，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。

2) 整理思路: 两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。

3) 信号量设置: 首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。

伪代码如下：

```
int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
writer () {  //写者进程
    while (1){
        P(rw); // 互斥访问共享文件
        Writing;  //写入
        V(rw) ;  //释放共享文件
    }
}
reader () {  // 读者进程
    while(1){
        P (mutex) ;  //互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        reading;  //读取
        P (mutex) ;  //互斥访问count变量
        count--; //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw) ;  //允许写进程写
        V (mutex) ;  //释放互斥变量 count
    }
}
```

在上面的算法中，读进程是优先的，也就是说，当存在读进程时，写操作将被延迟，并且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式下，会导致写进程可能长时间等待，且存在写进程“饿死”的情况。

#### 写进程优先

如果希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并且在上面的程序中 writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。

伪代码如下：

```
int count = 0;  //用于记录当前的读者数量
semaphore mutex = 1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
semaphore w=1;  //用于实现“写优先”
writer(){
    while(1){
        P(w);  //在无写进程请求时进入
        P(rw);  //互斥访问共享文件
        writing;  //写入
        V(rw);  // 释放共享文件
        V(w) ;  //恢复对共享支件的访问
    }
}
reader () {  //读者进程
    while (1){
        P (w) ;  // 在无写进程请求时进入
        P (mutex);  // 互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        V(w);  //恢复对共享文件的访问
        reading;  //读取
        P (mutex) ; //互斥访问count变量
        count--;  //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw);  //允许写进程写
        V (mutex);  //释放互斥变量count
    }
}
```

### 熟睡的理发师问题

熟睡的理发师问题（[The Sleeping-Baber Problem](https://en.wikipedia.org/wiki/Sleeping_barber_problem)）是操作系统中关于进程同步的一个经典问题。该问题模拟的描述是有顾客时，让理发师理发；没顾客时，让理发师睡觉。理发师与顾客就代表系统进程。

问题描述：

整个理发店由两个区域组成：有N把椅子的等候区和一把椅子的理发区。理发店有个嗜睡的理发师，当理发师完成给当前顾客理发时，他会前往等候区，看看是否还有其他人在等待，如果有，他会把其中一人带到理发区剪发，如果没有，他就会去理发区的椅子上睡觉；而每当有一个顾客到来时，都会看理发师在做什么，他有以下三种选择： 

1. 如果理发师正在睡觉，则叫醒理发师并开始理发； 
2. 如果理发师正在剪头发但等候区有空位，则进入等候区等候； 
3. 如果理发师在忙而等候区又满了，则掉头离开； 

基于简单的分析，这个问题的关键是要确保理发店正常运作，理发师剪掉任何到达的人的头发，直到没有更多的顾客，然后睡觉直到下一个顾客到达。在实践中，存在许多可能发生的问题，这些问题说明了操作系统的一般调度问题。

在出现竞争的情况下问题就来了，这和哲学家就餐问题是一样的。如果没有适当的解决方案，就会导致进程之间的“饿肚子”和“死锁”。

要解决这个问题，我们先分析一下这个问题中将存在的一些的特殊情况： 

1. Deadlock: 一个顾客到达理发店看到理发师正在剪头发，因此他回去等候区，当他正在路上的时候，理发师完成了当前顾客的发型并去检查等候区，由于那里没有人（顾客还没有到达），他回到椅子上睡觉。此时，理发师正在等待顾客，但顾客正在等待理发师，形成死锁； 
2. Starvation: 要是某些顾客来的比较巧，刚好碰到理发师给一个顾客理完发，于是理发师连忙给新来的这个顾客理发而不顾忌等候区的顾客，可能造成等候区的顾客无限的等待下去； 
3. Critical Section: 多个新来的顾客同时抢占椅子或同时又有一个顾客去理发，这便会涉及到椅子这个资源的分配问题，因此椅子便是这个问题的临界区资源。

Deadlock问题，我们可以通过维护两个信号量（customers和barber）来解决，我们假设理发师和顾客都可以持有或释放一个信号标，顾客持有信号标表示在坐在椅子上等待，理发师持有信号标表示在忙碌，他们可以随时改变自己的状态，因此，customers 表示等待的顾客人数，barber表示理发师是否正在忙碌；而Critical Section问题就使用一把互斥锁解决。

理发师在每次睡觉之前将检查一下等候区是否还有顾客在等待(wait(customers))，通知下一个顾客到理发区，并在开始理发前释放自己的信号标，标记正忙(signal(baber))；而每有新的顾客到来时，如果有空位，顾客就持有一个信号标并通知理发师(signal(customers))，然后在等候区等待理发师(wait(baber))；同时，使用互斥锁对椅子进行保护，防止了椅子被同时抢占造成资源的不同步。

> 以下伪代码保证理发师和顾客之间的同步，并且无死锁，但可能导致顾客的饥饿。饥饿问题可以维护一个队列，在顾客到达时添加进队列来解决，以便理发师可以先到先得的方式为他们服务（FIFO =>先进先出）。wait() 和 signal() 是信号量提供的功能。wait是指P()，signal()是指V()。

```
Semaphore customers = 0; // the number of customers currently in the waiting room, ready to be served
Semaphore barber = 0;
Semaphore accessSeats = 1;
int numberOfFreeSeats = N; 

Barber {
    while(1) {
        wait(customers); // waits for a customer (if none is available, go to sleep)
        wait(accessSeats); // mutex to protect the number of available seats
        numberOfFreeSeats++; // a chair gets free
        signal(barber); // bring customer for haircut, I am ready to cut.
        signal(accessSeats); // release the mutex on the chair
        // barber is cutting hair
    }
}

Customer {
    while(1) {
        wait(accessSeats); // protects seats so only 1 thread tries to sit in a chair if that's the case
        if(numberOfFreeSeats > 0) {
            numberOfFreeSeats--; // sitting down
            signal(customers); // notify the barber
            signal(accessSeats); // release the lock
            wait(barber); // wait in the waiting room if barber is busy
            // customer is having hair cut
        } else {
            signal(accessSeats); // release the lock
            // customer leaves
        }
   }
}
```

如果有多个理发师呢？这个问题就复杂多了，解决方案参考：

[Sleeping Barber algorithm (with multiple barbers)](https://stackoverflow.com/questions/19692515/sleeping-barber-algorithm-with-multiple-barbers)

### 三个烟鬼的问题

这也是计算机领域的并发问题，最早是1971年S.S.Patil讲述的。

问题描述:

假设一支香烟需要：1、烟草；2、卷烟纸；3、一根火柴。

假设一张圆桌上围座着三烟鬼。他们每个人都能提供无穷多的材料：一个有无穷多的烟草；一个有无穷多的卷烟纸；一个有无穷多的火柴。

假设还有一个不吸烟的协调人。他每次都会公正地要求两个人取出一份材料放到桌，然后通知第三个人。第三个人从桌上拿走另外两个人的材料，再加上自己的一份，卷一枝烟就会抽起来。这时，协调人看到桌上空了，就会再次随机叫两人向桌上贡献自己的材料。这个过程会无限地进行下去。

不会有人把桌上的东西藏起来。只有当他抽完一枝烟后，才会再卷另一枝。如果协调人将烟草和卷烟纸放到桌上，而那个有火柴的人仍在吸烟，那么烟草、卷烟纸就会原封不动地放在桌上，走到有火柴的人抽完烟取走桌上的材料。

解决方案:

我们使用3个信号量来表示放在桌子上的组合，信号量offer1、offer2、offer3分别表示烟草和纸的组合、烟草和火柴的组合、纸和火柴的组合。信号量finish用于互斥进行抽烟动作。

伪代码如下：

```
int random; //存储随机数
semaphore offer1=0; //定义信号量对应烟草和纸的组合
semaphore offer2=0; //定义信号量对应烟草和火柴的组合
semaphore offer3=0; //定义信号量对应纸和火柴的组合
semaphore finish=0; //定义信号量表示抽烟是否完成

//供应者
while(1){
    random = 任意一个整数随机数;
    random=random% 3;
    if(random==0)
        V(offerl) ; //提供烟草和纸
    else if(random==l) 
        V(offer2);  //提供烟草和火柴
    else
        V(offer3)  //提供纸和火柴
    // 任意两种材料放在桌子上;
    P(finish);
}

//拥有烟草者
while(1){
    P (offer3);
    // 拿纸和火柴，卷成烟，抽掉;
    V(finish);
}

//拥有纸者
while(1){
    P(offer2);
    // 烟草和火柴,卷成烟，抽掉；
    V(finish);
}

//拥有火柴者
while(1){
    P(offer1);
    // 拿烟草和纸，卷成烟，抽掉;
    v(finish);
}
```

### 参考

[维基百科-生产者消费者问题](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)

[维基百科-哲学家就餐问题](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)

[经典进程同步问题2：读者-写者问题](http://c.biancheng.net/cpp/html/2601.html)

[维基百科-吸烟者问题](https://en.wikipedia.org/wiki/Cigarette_smokers_problem)

[五个同步问题的经典模型之一：生产者/消费者问题](https://www.jianshu.com/p/b16296e9ac85)

### 优先级反转

// TODO

## 锁

### 为什么会有“锁”？

在多线程编程中，多个线程可能会访问同一个资源（称为临界资源），这样就很容易引发数据错乱和数据安全等问题，这时候就需要保证每次只有一个线程访问这一块资源，“锁”应运而生。

### OSSpinLock
